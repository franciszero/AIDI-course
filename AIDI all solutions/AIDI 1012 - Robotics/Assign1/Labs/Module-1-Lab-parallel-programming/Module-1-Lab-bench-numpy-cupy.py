# -*- coding: utf-8 -*-
"""Module-1-Lab-bench-numpy-cupy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PDr_u7_2yOUPl7LB_yMtO3a6rou7_g_Z

# **Performance best practices**

Array operations with GPUs can provide considerable speedups over CPU computing.

[CuPy](https://cupy.dev/) is an open-source array library for GPU-accelerated computing with Python. CuPy utilizes CUDA Toolkit libraries including cuBLAS, cuRAND, cuSOLVER, cuSPARSE, cuFFT, cuDNN and NCCL to make full use of the GPU architecture.

*  Most operations perform well on a GPU using CuPy. CuPy speeds up some operations more than 100X.

*  CuPy's interface is highly compatible with NumPy. CuPy supports various methods, indexing, data types, broadcasting and more. This [comparison table](https://docs.cupy.dev/en/stable/reference/comparison.html) shows a list of NumPy and their corresponding CuPy implementations.

[NumPy](https://numpy.org/doc/stable/user/whatisnumpy.html) is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.

## **Benchmarking speed- NumPy vs CuPy**

In this tutorial, we will perform some opeations using NumPy and CuPy library and we will benchmark the time.
"""

# import libraries
import numpy as np
import cupy

"""Let's start with creating an array using NumPy and CuPy and compare the time.

### **Creating an array with NumPy**
"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# np_var1 = np.random.random((10000, 10000))
# np_var2 = np.random.random((10000, 10000))

"""### **Creating and array with CuPy**"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# cp_var1 = cupy.random.random((10000, 10000))
# cp_var2 = cupy.random.random((10000, 10000))
# cupy.cuda.Stream.null.synchronize()

# print the numpy array
np_var1

# print the cupy array
cp_var1

"""### **Trigonometric function**

Let's do some trigonometric operations and compare the time.
"""

# Commented out IPython magic to ensure Python compatibility.
# %timeit bool((np.sin(np_var1) ** 2 + np.cos(np_var1) ** 2 == 1).all())

# Commented out IPython magic to ensure Python compatibility.
# %timeit bool((cupy.sin(cp_var2) ** 2 + cupy.cos(cp_var2) ** 2 == 1).all())

"""### **Multiplying the array**

Let's do some aritmetic operations and compare the time.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# np_var1 *= 10

# Commented out IPython magic to ensure Python compatibility.
# %%time
# cp_var1 *= 10
# cupy.cuda.Stream.null.synchronize()

"""### **Performing multiple operations on the array**"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# np_var1 *= 10
# np_var2 *= 20
# np_var1 *= np_var2

# Commented out IPython magic to ensure Python compatibility.
# %%time
# cp_var1 *= 10
# cp_var2 *= 20
# cp_var1 *= cp_var2
# cupy.cuda.Stream.null.synchronize()

"""# **Exercise**
You can also find other operations from [the comparison table](https://docs.cupy.dev/en/stable/reference/comparison.html).

Use the following operations do NumPy and CuPy implementation and then benchmark the times. 
- numpy.absolute | cupy.absolute
- numpy.median | cupy.median
- numpy.resize | cupy.resize
- numpy.shape | cupy.shape
- numpy.ndarray.fill() | cupy.ndarray.fill()
"""

